classdef ProtoObject < robotics.ros.Message
  %ProtoObject MATLAB implementation of trimbot_msgs/ProtoObject
  %   This class was automatically generated by
  %   robotics.ros.msg.internal.gen.MessageClassGenerator.
  
  %   Copyright 2014-2019 The MathWorks, Inc.
  
  %#ok<*INUSD>
  
  properties (Constant)
    MessageType = 'trimbot_msgs/ProtoObject' % The ROS message type
  end
  
  properties (Constant, Hidden)
    MD5Checksum = '7dc67b769b305b91716f6cf5fde5c87c' % The MD5 Checksum of the message definition
  end
  
  properties (Access = protected)
    JavaMessage % The Java message object
  end
  
  properties (Constant, Access = protected)
    GeometryMsgsPoseClass = robotics.ros.msg.internal.MessageFactory.getClassForType('geometry_msgs/Pose') % Dispatch to MATLAB class for message type geometry_msgs/Pose
    GeometryMsgsVector3Class = robotics.ros.msg.internal.MessageFactory.getClassForType('geometry_msgs/Vector3') % Dispatch to MATLAB class for message type geometry_msgs/Vector3
    StdMsgsHeaderClass = robotics.ros.msg.internal.MessageFactory.getClassForType('std_msgs/Header') % Dispatch to MATLAB class for message type std_msgs/Header
  end
  
  properties (Dependent)
    Header
    Id
    Label
    Shape
    Pose
    Scale
    Seg
    Mesh
    Dim
    Occup
  end
  
  properties (Access = protected)
    Cache = struct('Header', [], 'Pose', [], 'Scale', []) % The cache for fast data access
  end
  
  properties (Constant, Hidden)
    PropertyList = {'Dim', 'Header', 'Id', 'Label', 'Mesh', 'Occup', 'Pose', 'Scale', 'Seg', 'Shape'} % List of non-constant message properties
    ROSPropertyList = {'dim', 'header', 'id', 'label', 'mesh', 'occup', 'pose', 'scale', 'seg', 'shape'} % List of non-constant ROS message properties
  end
  
  methods
    function obj = ProtoObject(msg)
      %ProtoObject Construct the message object ProtoObject
      import com.mathworks.toolbox.robotics.ros.message.MessageInfo;
      
      % Support default constructor
      if nargin == 0
        obj.JavaMessage = obj.createNewJavaMessage;
        return;
      end
      
      % Construct appropriate empty array
      if isempty(msg)
        obj = obj.empty(0,1);
        return;
      end
      
      % Make scalar construction fast
      if isscalar(msg)
        % Check for correct input class
        if ~MessageInfo.compareTypes(msg(1), obj.MessageType)
          error(message('robotics:ros:message:NoTypeMatch', obj.MessageType, ...
            char(MessageInfo.getType(msg(1))) ));
        end
        obj.JavaMessage = msg(1);
        return;
      end
      
      % Check that this is a vector of scalar messages. Since this
      % is an object array, use arrayfun to verify.
      if ~all(arrayfun(@isscalar, msg))
        error(message('robotics:ros:message:MessageArraySizeError'));
      end
      
      % Check that all messages in the array have the correct type
      if ~all(arrayfun(@(x) MessageInfo.compareTypes(x, obj.MessageType), msg))
        error(message('robotics:ros:message:NoTypeMatchArray', obj.MessageType));
      end
      
      % Construct array of objects if necessary
      objType = class(obj);
      for i = 1:length(msg)
        obj(i,1) = feval(objType, msg(i)); %#ok<AGROW>
      end
    end
    
    function header = get.Header(obj)
      %get.Header Get the value for property Header
      if isempty(obj.Cache.Header)
        obj.Cache.Header = feval(obj.StdMsgsHeaderClass, obj.JavaMessage.getHeader);
      end
      header = obj.Cache.Header;
    end
    
    function set.Header(obj, header)
      %set.Header Set the value for property Header
      validateattributes(header, {obj.StdMsgsHeaderClass}, {'nonempty', 'scalar'}, 'ProtoObject', 'Header');
      
      obj.JavaMessage.setHeader(header.getJavaObject);
      
      % Update cache if necessary
      if ~isempty(obj.Cache.Header)
        obj.Cache.Header.setJavaObject(header.getJavaObject);
      end
    end
    
    function id = get.Id(obj)
      %get.Id Get the value for property Id
      id = typecast(int32(obj.JavaMessage.getId), 'uint32');
    end
    
    function set.Id(obj, id)
      %set.Id Set the value for property Id
      validateattributes(id, {'numeric'}, {'nonempty', 'scalar'}, 'ProtoObject', 'Id');
      
      obj.JavaMessage.setId(id);
    end
    
    function label = get.Label(obj)
      %get.Label Get the value for property Label
      label = typecast(int32(obj.JavaMessage.getLabel), 'uint32');
    end
    
    function set.Label(obj, label)
      %set.Label Set the value for property Label
      validateattributes(label, {'numeric'}, {'nonempty', 'scalar'}, 'ProtoObject', 'Label');
      
      obj.JavaMessage.setLabel(label);
    end
    
    function shape = get.Shape(obj)
      %get.Shape Get the value for property Shape
      shape = typecast(int32(obj.JavaMessage.getShape), 'uint32');
    end
    
    function set.Shape(obj, shape)
      %set.Shape Set the value for property Shape
      validateattributes(shape, {'numeric'}, {'nonempty', 'scalar'}, 'ProtoObject', 'Shape');
      
      obj.JavaMessage.setShape(shape);
    end
    
    function pose = get.Pose(obj)
      %get.Pose Get the value for property Pose
      if isempty(obj.Cache.Pose)
        obj.Cache.Pose = feval(obj.GeometryMsgsPoseClass, obj.JavaMessage.getPose);
      end
      pose = obj.Cache.Pose;
    end
    
    function set.Pose(obj, pose)
      %set.Pose Set the value for property Pose
      validateattributes(pose, {obj.GeometryMsgsPoseClass}, {'nonempty', 'scalar'}, 'ProtoObject', 'Pose');
      
      obj.JavaMessage.setPose(pose.getJavaObject);
      
      % Update cache if necessary
      if ~isempty(obj.Cache.Pose)
        obj.Cache.Pose.setJavaObject(pose.getJavaObject);
      end
    end
    
    function scale = get.Scale(obj)
      %get.Scale Get the value for property Scale
      if isempty(obj.Cache.Scale)
        obj.Cache.Scale = feval(obj.GeometryMsgsVector3Class, obj.JavaMessage.getScale);
      end
      scale = obj.Cache.Scale;
    end
    
    function set.Scale(obj, scale)
      %set.Scale Set the value for property Scale
      validateattributes(scale, {obj.GeometryMsgsVector3Class}, {'nonempty', 'scalar'}, 'ProtoObject', 'Scale');
      
      obj.JavaMessage.setScale(scale.getJavaObject);
      
      % Update cache if necessary
      if ~isempty(obj.Cache.Scale)
        obj.Cache.Scale.setJavaObject(scale.getJavaObject);
      end
    end
    
    function seg = get.Seg(obj)
      %get.Seg Get the value for property Seg
      javaArray = obj.JavaMessage.getSeg;
      array = obj.readJavaArray(javaArray, 'uint32');
      seg = uint32(array);
    end
    
    function set.Seg(obj, seg)
      %set.Seg Set the value for property Seg
      if ~isvector(seg) && isempty(seg)
        % Allow empty [] input
        seg = uint32.empty(0,1);
      end
      
      validateattributes(seg, {'numeric'}, {'vector'}, 'ProtoObject', 'Seg');
      
      javaArray = obj.JavaMessage.getSeg;
      array = obj.writeJavaArray(seg, javaArray, 'uint32');
      obj.JavaMessage.setSeg(array);
    end
    
    function mesh = get.Mesh(obj)
      %get.Mesh Get the value for property Mesh
      javaArray = obj.JavaMessage.getMesh;
      array = obj.readJavaArray(javaArray, 'uint32');
      mesh = uint32(array);
    end
    
    function set.Mesh(obj, mesh)
      %set.Mesh Set the value for property Mesh
      if ~isvector(mesh) && isempty(mesh)
        % Allow empty [] input
        mesh = uint32.empty(0,1);
      end
      
      validateattributes(mesh, {'numeric'}, {'vector'}, 'ProtoObject', 'Mesh');
      
      javaArray = obj.JavaMessage.getMesh;
      array = obj.writeJavaArray(mesh, javaArray, 'uint32');
      obj.JavaMessage.setMesh(array);
    end
    
    function dim = get.Dim(obj)
      %get.Dim Get the value for property Dim
      javaArray = obj.JavaMessage.getDim;
      array = obj.readJavaArray(javaArray, 'uint32');
      dim = uint32(array);
    end
    
    function set.Dim(obj, dim)
      %set.Dim Set the value for property Dim
      validateattributes(dim, {'numeric'}, {'vector', 'numel', 3}, 'ProtoObject', 'Dim');
      
      javaArray = obj.JavaMessage.getDim;
      array = obj.writeJavaArray(dim, javaArray, 'uint32');
      obj.JavaMessage.setDim(array);
    end
    
    function occup = get.Occup(obj)
      %get.Occup Get the value for property Occup
      javaArray = obj.JavaMessage.getOccup;
      array = obj.readJavaArray(javaArray, 'logical');
      occup = logical(array);
    end
    
    function set.Occup(obj, occup)
      %set.Occup Set the value for property Occup
      if ~isvector(occup) && isempty(occup)
        % Allow empty [] input
        occup = logical.empty(0,1);
      end
      
      validateattributes(occup, {'logical', 'numeric'}, {'vector'}, 'ProtoObject', 'Occup');
      
      javaArray = obj.JavaMessage.getOccup;
      array = obj.writeJavaArray(occup, javaArray, 'logical');
      obj.JavaMessage.setOccup(array);
    end
  end
  
  methods (Access = protected)
    function resetCache(obj)
      %resetCache Resets any cached properties
      obj.Cache.Header = [];
      obj.Cache.Pose = [];
      obj.Cache.Scale = [];
    end
    
    function cpObj = copyElement(obj)
      %copyElement Implements deep copy behavior for message
      
      % Call default copy method for shallow copy
      cpObj = copyElement@robotics.ros.Message(obj);
      
      % Clear any existing cached properties
      cpObj.resetCache;
      
      % Create a new Java message object
      cpObj.JavaMessage = obj.createNewJavaMessage;
      
      % Iterate over all primitive properties
      cpObj.Id = obj.Id;
      cpObj.Label = obj.Label;
      cpObj.Shape = obj.Shape;
      cpObj.Seg = obj.Seg;
      cpObj.Mesh = obj.Mesh;
      cpObj.Dim = obj.Dim;
      cpObj.Occup = obj.Occup;
      
      % Recursively copy compound properties
      cpObj.Header = copy(obj.Header);
      cpObj.Pose = copy(obj.Pose);
      cpObj.Scale = copy(obj.Scale);
    end
    
    function reload(obj, strObj)
      %reload Called by loadobj to assign properties
      obj.Id = strObj.Id;
      obj.Label = strObj.Label;
      obj.Shape = strObj.Shape;
      obj.Seg = strObj.Seg;
      obj.Mesh = strObj.Mesh;
      obj.Dim = strObj.Dim;
      obj.Occup = strObj.Occup;
      obj.Header = feval([obj.StdMsgsHeaderClass '.loadobj'], strObj.Header);
      obj.Pose = feval([obj.GeometryMsgsPoseClass '.loadobj'], strObj.Pose);
      obj.Scale = feval([obj.GeometryMsgsVector3Class '.loadobj'], strObj.Scale);
    end
  end
  
  methods (Access = ?robotics.ros.Message)
    function strObj = saveobj(obj)
      %saveobj Implements saving of message to MAT file
      
      % Return an empty element if object array is empty
      if isempty(obj)
        strObj = struct.empty;
        return
      end
      
      strObj.Id = obj.Id;
      strObj.Label = obj.Label;
      strObj.Shape = obj.Shape;
      strObj.Seg = obj.Seg;
      strObj.Mesh = obj.Mesh;
      strObj.Dim = obj.Dim;
      strObj.Occup = obj.Occup;
      strObj.Header = saveobj(obj.Header);
      strObj.Pose = saveobj(obj.Pose);
      strObj.Scale = saveobj(obj.Scale);
    end
  end
  
  methods (Static, Access = {?matlab.unittest.TestCase, ?robotics.ros.Message})
    function obj = loadobj(strObj)
      %loadobj Implements loading of message from MAT file
      
      % Return an empty object array if the structure element is not defined
      if isempty(strObj)
        obj = robotics.ros.custom.msggen.trimbot_msgs.ProtoObject.empty(0,1);
        return
      end
      
      % Create an empty message object
      obj = robotics.ros.custom.msggen.trimbot_msgs.ProtoObject;
      obj.reload(strObj);
    end
  end
end
